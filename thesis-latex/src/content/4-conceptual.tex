\chapter{Conceptional System Design}


\section{MVC Pattern}
\label{mvc}

The Model-View-Controller (MVC) is a software architecture pattern for user interface implementation, where the application logic is separated from the user interface.

In object-oriented programming the Model is the objects where the data from the database is stored. The View is the presentation layer, what the user sees and interacts with. The Controller will process and respond to the user requests and invoke the changes in the Model. 

The MVC pattern is memory efficient, because multiple views can share the same underlying data model. Controllers can be separated by events. This let's the developer to create a controller hierarchy, because a controller for a keyboard event is different from a controller for a mouse event. Views implement an instance of a controller, that can be changed at run-time, because we can be disabled and enabled.


\begin{figure}[!ht]
	\includegraphics[width=\textwidth]{figures/klasszikus_mvc_webalkalmazas.pdf}
	\caption{Classic MVC Web Application \\ Made by Bence Golda}
	\label{fig:classic-mvc-webapplication}
\end{figure}

In web applications the browser communicates with a controller. When the user sends a request, routing will decide which controller will handle the request. The chosen controller talks to the model to get the relevant data. If it's necessary, the model will send data to or ask for data from the database, the API or the local storage. During this process, the data has to be transformed via marshalling. Marshalling is the process, that transforms the data between storable and sendable dataformats. When the model returns the desired data to the controller, it will forward the data to the view. The presentation layer will decide which page has to be returned to the browser, binds the data to the view template and returns it.

\section{System Design}

\todo{bevezetőszöveg?}
\begin{figure}[!ht]
	\includegraphics[width=\textwidth]{figures/atfogo_rendszerterv_teljes.pdf}
	\caption{Conceptional System Design}
	\label{fig:conceptional-system-design}
\end{figure}

\todo{ábrán kijavítani, hogy a web server az külön szó}

The main components are the followings:

\begin{itemize}
	\item \textbf{Client:} A web portal, that is the communication bridge between the user and the web server. There will be three different modules: student, teacher and administrator. The different client modules can only communicate with the web server, and they cannot communicate with each other.
	\item \textbf{Database:} A database to store the system's data \see{ER-model}. 
	\item \textbf{Git:} A database to store the students' homeworks. Every student will get a different git repository for each laboratory.
	\item \textbf{Load Balancer:} It prevents the client from contacting the web server directly and solves the scalability problem. The client sends its requests to the load balancer, and it will send it to one of the web servers, depending on what kind of task it is and how overloaded
	\item \textbf{Object-relational mapping:} It converts the data between the tasks and the database. \todo{ORM az ez, igaz?}
	\item \textbf{Message Bus:} A component, what supports messaging between other components. The web server, the task manager, the message queue and the workers will use this to send tasks to each other.
	\item \textbf{Message Queue:} A component, what will forward the incoming tasks from the task manager to the right worker for processing.
	\item \textbf{Task Manager:} A special worker. It gets tasks from the web server to decide which worker has to process it. After the decision it sends the task to the message queue.
	\item \textbf{Web Server:} The server that runs the API's code. This component processes the incoming requests from the clients via the load balancer, and creates tasks and provides the data from the databases via the ORM. It will forward these tasks to the task manager. The API is written in Ruby on Rails. 
	\item \textbf{Worker:} This will process the task, e.g., writing data to the database.
\end{itemize}

\subsubsection{Scalability}

\newparagraph{Client}

To solve the scalability problem, the client's code will run in a web browser for every user. Since the code will be downloaded, this creates a new client every time a user opens the web portal in a web browser.
 
\newparagraph{Web Server}

If there's no load balancer between the client and the web server, then one server will get each request. With thousands of user this can lead to overload and maximize the response time. With a load balancer, the requests will first arrive at the load balancer, and it will decide which web server will handle that request and forwards it to that web server. The choice depends on what kind of task it is and which web server has less requests. The load balancer's purpose is to avoid overload and minimize the response time.
 

\subsection{Frontend System Design}
\todo{frontend ábra}

\subsection{Entity–relationship model}
\label{ER-model}

\begin{figure}[!ht]
	\includegraphics[width=\textwidth]{figures/ER.pdf}
	\caption{Entity–relationship model}
	\label{fig:er}
\end{figure}

\todo{magyarázat}
